[OK] LUSTRE_USER_MAGIC_V3 => pool support
[OK] non reg pool support
[OK] pb matching class si stripe pas recupere

- return value of robinhood when it is killed...

- selection des tests de non reg suivant le purpose

@TODO if the command is '--migrate-class', '--migrate-user', '--migrate-group',
      check that the entry still matches

- nonreg migrate-class, purge-class
- test summary line ds le mode tmp fs mgr

- alert si le parcours est bloqué
- exit si trop de blocage?

- wrapper repair table dans rbh-config?

Pusher 220p1 dans la repo oracle


Doc:
====
(* config sqlite et disclaimer)
* fileclasses are matched in the order they are targetted
 /!\ target =  A_inter_B
     target = A
	=> OK
	inverse => NOK

--migrate-class
--purge-class

Features:
=========
* prise en compte des classes pour les repertoires
* Daily report (migr, purge, ...)
* possibilite de n'appliquer un trigger qu'a un sous-repertoire, un fileset ou autre...
* 'Heriter' des parametres d'un parent
* modules dynamiques
* Scan antivirus parallelise sur plusieurs clients!

Fixes:
======
* verifier l'existence de CLF_UNLINK_LAST pour TMP_FS_MGR sur Lustre2
* verifier utilisation de TerminateThread
(* trigger sur nbr d'inodes: pas de sens pour Lustre-HSM)

* evenement leves par un import??

Optim:
======
* ajout d'un masque des attributs modifies, pour savoir ce qu'on met a jour

* filter les ignore_fileclass dans les applications de policy.

* bench perf DB.
* separer les adherences a chaque 'purpose' dans un module separe
* statut special pour les fichiers avec erreur de migration?
(* se rappeler des alertes deja envoyees.)

* BUG FIX: considerer tous les chemins renvoyés par fid2path pour matcher les filesets et conditions

* remettre le follow flag en fonctionnement par defaut lorsqu'il sera implemente correctement

* pb <defunc> => bz 23120
* report bug CL_TIME changelog => bz 23035 => fixed

* ajout appel a la liblustreAPI pour recuperer le fid des parents + sanity correspondant

Mise au point de benchs pour comparer la version actuelle au futures optimisations
 * duree de scan
 * creation rate soutenable en lecture de chglogs (sur un MESCA)
 * nombre de RPC Lustre emises...

Tests:
 * evaluer l'impact du sleep dans le polling des chglogs, en fonction de la charge du FS

Alertes:
========
* last_alert dans la table pour ne pas renvoyer une alerte?



================ Resultats de tests avec erreurs =========================

=> pb thread-safety chglogs

Getpath needed because name changed 'file.0.3'->''
Getpath needed because name changed 'file.10.3'->''
Getpath needed because name changed 'file.10.2'->''
Getpath needed because name changed 'file.10.1'->''
Getpath needed because name changed 'file.200.3'->''
Getpath needed because name changed 'file.200.2'->''
Getpath needed because name changed 'file.200.1'->''

2)
copytool: catch ctrl+c ?

* verifier qu'il n'y a plus de probleme 32/64 bits pours les lignes de rapport (SQLite notamment).
BUGS:
	2010/03/17 11:20:01 robinhood@fortoy131[3208/5]: Purged '/tmp/rh-report' using policy 'default', last access 4.3min ago | size=747716, last_access=1268820942, last_mod=46915196595150, storage_units=(none)

===============================================================================

* Remise a jour de la doc: handle-events => readlog

* Fournir des RPMs binaires


* hsm_remove active par defaut ?
* support si un OST est desactive

* report: afficher le status d'une entree

Plateformes de compilation:
- Lustre 1.6.7.2, kernel 2.6.18-92.1.26.el5
- Lustre 1.8.2, kernel 2.6.18-164.6.1.el5
- Lustre 1.10.0.36, kernel 2.6.18-164.11.1.el5

======================================
* TODO LUSTRE: dans hsm_state: indiquer si l'entree est en cours de migration
* TODO LUSTRE: dans llapi_changelog_start: virer le fork()

======================================
TODO copytool:
* HPSS 7.3 sur petrea6

=======================================


Application des politiques:

- Fournir un outil permettant d'interoger le status d'un fichier (par fid, par path),
  et en fonction du status, d'evaluer son eligibilite a la purge/migration, son rang...

  Eventuellement expliquer pourquoi il matches une certaine politique tel que:

            rc = BoolExpr2str( &entry_proc_conf.alert_list[i].boolexpr, stralert, 2048 );
            if ( rc < 0 )
                strcpy( stralert, "Error building alert string" );

            PrintAttrs( strvalues, 2048, &p_op->entry_attr,
                        entry_proc_conf.alert_list[i].attr_mask );


- verifier l'action appliquee la database lors de la purge? de la migration?

- request aggregation

- check that FS path or tree condition match the mount point
- Condition sur une commande externe
- test condition par pool
- seuil de migration par pool => tester par pool et par OST

Dumper l'état du processus sur un siguser1

- rajouter force commit là ou necessaire pour les purges, etc...
~x Arret propre par sigterm (fs scan bloqué)

- Tester la resistance aux deconnexions lorsqu'on utilise pas les prepared statements
	- Le cas echeant, ne pas utiliser les prepared statements (meilleure resistance aux deconnexions a tester)

- Traquer tous les @TODO

(- ameliorer fonctions de hash)

- trigger sur le nombre d'inodes

[dur]- verifier que les politiques de migration ont bien last_mod '>' et last_archive '>'
[dur]- verifier que les politiques de purge ont bien last_access '>'

================================================================================


- Doxygen

- Blinder les prepared statements au redemarrage du serveur MySQL

scan recovery:
1) recupere le dernier timestamp de debut de dernier parcours
2) si une entree est deja presente avec un timestamp superieur, on ne l'update pas


- ifdef pour le calcul des temps de traitement

- man
- Mettre les tableaux statics en extern dans le .h et implementes dans les .c
- Faire un coup de gprof, valgrind
- Test perfs update lastmod

================================================================================

[General]

- Traquer tous les @todo

- methode de calcul de last_access dependante du type d'application (est-il judicieux que ctime change => fichier considere dirty?)
- methode de calcul de last_mod dependante du type d'application
- remplacer strerror par strerror_r 

[Packaging]

- Check Lustre et Mysql

[Documentation]

- Documentation utilisateur. (admin guide)
- Doxygen
- Document de design détaillé du ListMgr + evaluation de techno

[ConfigParsing]

[Rmdir]

[FSscan]

[ListMgr]

- Report: stats COUNT_DISTINCT

- Support des filtres complexes a base d'expressions booleennes => utile ?

- optimisation des massupdate (comme fait pour mass remove)
- Avoir une fonction db dependant pour la creation de table temporaire a partir d'un requete ?
- Avoir qq chose de db dependant pour la creation de champs auto-incrementaux
- MassUpdate: support des filtres multi-tables ?
- Script de creation/destruction de la base generee a partir du .def ?

[Entry Processor Pipeline]

- Merger toutes les alertes dans un meme mail + fonction FlushAlerts().
- Process entries at next steps if there is no constraint ?

[Policies]

- Condition on external command
- Condition on stripe count

[ResourceMonitor]

- Ajout d'une option pour forcer une purge meme si aucun scan n'a ete effectue completement

- Trigger purge on external command

- Trigger sur le nombre d'inodes?
- Functions for parsing command ouput and start a custom purge

- Build SQL request from policies?

================================================================================
Besoins IGS:
x statistiques sur les repertoires (nbr d'entrees...)

Besoins SSR:
x cracher les valeurs par défaut
x démarrage d'une purge sur un autre critère que le df: typiquement % quota/groupe
- démarrage d'une purge sur un script externe
- plages horaires pour les parcours et les purges
x ne pas descendre dans un répertoire (ex: .snapshot)
x one-shot avec watermarks
x one-shot: purge par plus ancien (en fait démon qui s'arrête qd le df < low watermark)

