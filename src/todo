- support env var in config file
- make size_acct optional

- manage LU-3620 in changelog reader
- restore bulk search in rbh-find as a new option
- support ost sets in rbh_find
- non reg test for OST sets
- backport recent modes in std_pipeline to diff pipeline.
- hardlink management in policies, recovery, etc.
- check how mknode'd entries and handled by backup mode and rbh-diff
- fix name update warnings

- recovery MDT with HSM: set status of files
- recov-tools: must reset fid of OST objects after MDS recovery

- See this for Lustre 2.4:
 * Sigh, because pre-2.4 uses
 * struct lov_mds_md_v1 {
 *      ........
 *      __u64 lmm_object_id;
 *      __u64 lmm_object_seq;
 *      ......
 *      }
 * to identify the LOV(MDT) object, and lmm_object_seq will
 * be normal_fid, which make it hard to combine these conversion
 * to ostid_to FID. so we will do lmm_oi/fid conversion separately
 *
 * We can tell the lmm_oi by this way,
 * 1.8: lmm_object_id = {inode}, lmm_object_gr = 0
 * 2.1: lmm_object_id = {oid < 128k}, lmm_object_seq = FID_SEQ_NORMAL
 * 2.4: lmm_oi.f_seq = FID_SEQ_NORMAL, lmm_oi.f_oid = {oid < 128k},
 *      lmm_oi.f_ver = 0
 *
 * But currently lmm_oi/lsm_oi does not have any "real" usages,
 * except for printing some information, and the user can always
 * get the real FID from LMA, besides this multiple case check might
 * make swab more complicate. So we will keep using id/seq for lmm_oi.


/!\ symlink can change in case of inode recycling (ext3/4, ...)

- db diff option: list changes since xxx
- bench diff
- test diff for hardlinks

- add rbh-find --details
- add rbh-find -print -exec -delete...
- refactoring lmgr_init

- change code formatting to GNU
- add code format check as git hook

- update TRAC/wiki/...

-check why updating stripe_info complains about duplicate entry error

Replace:
    --dump-user user
        Dump all entries for the given user.
    --dump-group group
        Dump all entries for the given group.
    --dump-ost ost_index
        Dump all entries on the given OST.
    --filter-path
by a find-like syntax.

- support filter for softrm list
- add signal handler to recovery function
- Put pdf doc to /usr/share/doc/robinhood
- Generate man pages from --help 
- Configuration template for different uses (stat and monitoring only,
purge when fs usage reaches a threashold, purge at scheduled interval...)

BACKUP:
 - si recov appele sans option: aide
 - implementer recov status
 - backup quotidien de la base robinhood
 - CREATE du fichier dans le sbin?
 (- affichage de la cos choisie dans les logs)
 (- mapping chemin_montage/commande copie)
 - mise a jour du delai de suppression dans le backend
 - commande de resync que des md

lustre-HSM:
 - sauvegarde des metadata dans une table (au release)
 - conserver les infos sur tt les entrees (rep, ...) a des fins de backup

- list_mgr/listmgr_remove.c
	escape string in softrm function

Finitions:
- voir si les 1024 peuvent etre remplaces par RBH_PATH_MAX
- tests de non reg: verifier le CriteriaToFilter sur les OST

- criteria on stripe_count

- usage in db when there is no trigger on OST usage...
- additional info in var table

- verify HSM tests #3, #8, #9, #14
- switch regression tests depending on the compilation flavor

@TODO if the command is '--migrate-class', '--migrate-user', '--migrate-group',
      check that the entry still matches

Doc:
* doc backend ext/backup

Features:
=========
- backup:
	tout flusher même si synchro

* take classes into account for directories
* Daily report (migr, purge, ...)
* possibilite de n'appliquer un trigger qu'a un sous-repertoire, un fileset ou autre...
* 'Heriter' des parametres d'un parent
* modules dynamiques

Fixes:
======
(* trigger sur nbr d'inodes: pas de sens pour Lustre-HSM)

* evenement leves par un import??

Optim:
======
* filter les ignore_fileclass dans les applications de policy.

* separer les adherences a chaque 'purpose' dans un module separe
* statut special pour les fichiers avec erreur de migration?
(* se rappeler des alertes deja envoyees.)

* remettre le follow flag en fonctionnement par defaut lorsqu'il sera implemente correctement

* ajout appel a la liblustreAPI pour recuperer le fid des parents + sanity correspondant

Mise au point de benchs pour comparer la version actuelle au futures optimisations
 * duree de scan
 * creation rate soutenable en lecture de chglogs
 * nombre de RPC Lustre emises...

Tests:
 * evaluer l'impact du sleep dans le polling des chglogs, en fonction de la charge du FS

Alertes:
========
* last_alert dans la table pour ne pas renvoyer une alerte?


===============================================================================

* support si un OST est desactive

* report: afficher le status d'une entree

=======================================


Application des politiques:

- Fournir un outil permettant d'interoger le status d'un fichier (par fid, par path),
  et en fonction du status, d'evaluer son eligibilite a la purge/migration, son rang...

  Eventuellement expliquer pourquoi il matches une certaine politique tel que:

            rc = BoolExpr2str( &entry_proc_conf.alert_list[i].boolexpr, stralert, 2048 );
            if ( rc < 0 )
                strcpy( stralert, "Error building alert string" );

            PrintAttrs( strvalues, 2048, &p_op->entry_attr,
                        entry_proc_conf.alert_list[i].attr_mask );


- verifier l'action appliquee la database lors de la purge? de la migration?

- request aggregation

- check that FS path or tree condition match the mount point
- Condition sur une commande externe
- test condition par pool
- seuil de migration par pool => tester par pool et par OST

Dumper l'état du processus sur un siguser1

- rajouter force commit là ou necessaire pour les purges, etc...
~x Arret propre par sigterm (fs scan bloqué)

- Traquer tous les @TODO

(- ameliorer fonctions de hash)

- trigger sur le nombre d'inodes

[dur]- verifier que les politiques de migration ont bien last_mod '>' et last_archive '>'
[dur]- verifier que les politiques de purge ont bien last_access '>'

================================================================================


- Doxygen

scan recovery:
1) recupere le dernier timestamp de debut de dernier parcours
2) si une entree est deja presente avec un timestamp superieur, on ne l'update pas


- ifdef pour le calcul des temps de traitement

- man
- Mettre les tableaux statics en extern dans le .h et implementes dans les .c
- Faire un coup de gprof, valgrind
- Test perfs update lastmod

================================================================================

[General]

- Traquer tous les @todo

- methode de calcul de last_access dependante du type d'application (est-il judicieux que ctime change => fichier considere dirty?)
- methode de calcul de last_mod dependante du type d'application
- remplacer strerror par strerror_r 

[Packaging]

- Check Lustre et Mysql

[Documentation]

- Documentation utilisateur. (admin guide)
- Doxygen
- Document de design détaillé du ListMgr + evaluation de techno

[ConfigParsing]

[Rmdir]

[FSscan]

[ListMgr]

- Report: stats COUNT_DISTINCT

- Support des filtres complexes a base d'expressions booleennes => utile ?

- optimisation des massupdate (comme fait pour mass remove)
- Avoir une fonction db dependant pour la creation de table temporaire a partir d'un requete ?
- Avoir qq chose de db dependant pour la creation de champs auto-incrementaux
- MassUpdate: support des filtres multi-tables ?
- Script de creation/destruction de la base generee a partir du .def ?

[Entry Processor Pipeline]

- Merger toutes les alertes dans un meme mail + fonction FlushAlerts().
- Process entries at next steps if there is no constraint ?

[Policies]

- Condition on external command
- Condition on stripe count

[ResourceMonitor]

- Ajout d'une option pour forcer une purge meme si aucun scan n'a ete effectue completement

- Trigger purge on external command

- Trigger sur le nombre d'inodes?
- Functions for parsing command ouput and start a custom purge

- Build SQL request from policies?

================================================================================
Besoins IGS:
x statistiques sur les repertoires (nbr d'entrees...)

Besoins SSR:
x cracher les valeurs par défaut
x démarrage d'une purge sur un autre critère que le df: typiquement % quota/groupe
- démarrage d'une purge sur un script externe
- plages horaires pour les parcours et les purges
x ne pas descendre dans un répertoire (ex: .snapshot)

